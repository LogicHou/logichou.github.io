<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<search>
  
  <entry>
    <title>Go常见的并发模式 - 超时与取消模式</title>
    <url>/post/2022/09/go-concurrency-pattern-4/</url>
    <categories><category>Go</category>
    </categories>
    <tags>
      <tag>Go</tag>
      <tag>并发</tag>
    </tags>
    <content type="html"><![CDATA[示例1 尝试从天气中心获取数据 编写一个从气象数据中心获取天气信息的客户端。该客户端每次会并发向三个气象数据服务中心发起数据查询请求，并以最快返回的那个响应信息作为此次请求的应答返回值。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package main import ( &#34;io/ioutil&#34; &#34;log&#34; &#34;net/http&#34; &#34;net/http/httptest&#34; &#34;time&#34; ) type result struct { value string } func first(servers ...*httptest.Server) (result, error) { c := make(chan result, len(servers)) // 带缓冲的channel queryFunc := func(server *httptest.Server) { url := server.URL resp, err := http.Get(url) if err != nil { log.Printf(&#34;http get error: %s\n&#34;, err) return } defer resp.Body.Close() body, _ := ioutil.ReadAll(resp.Body) c &lt;- result{ // 三个发起查询的goroutine都会将应答结构写入这里，由于是带缓冲的channel最大同时可以放入3个数据 value: string(body), } } for _, serv := range servers { go queryFunc(serv) } return &lt;-c, nil // 从这个带缓冲的channel中返回最先进入的那个，也就是最快返回气象数据的那个 } func fakeWeatherServer(name string) *httptest.Server { return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { log.Printf(&#34;%s receive a http request\n&#34;, name) time.Sleep(1 * time.Second) w.Write([]byte(name + &#34;:ok&#34;)) })) } func main() { result, err := first(fakeWeatherServer(&#34;open-weather-1&#34;), fakeWeatherServer(&#34;open-weather-2&#34;), fakeWeatherServer(&#34;open-weather-3&#34;)) if err != nil { log.Println(&#34;invoke first error:&#34;, err) return } log.Println(result) } 1 2 3 4 5 $ go run main.go 2022/09/18 22:41:59 open-weather-3 receive a http request 2022/09/18 22:41:59 open-weather-2 receive a http request 2022/09/18 22:41:59 open-weather-1 receive a http request 2022/09/18 22:42:00 {open-weather-2:ok} 示例2 超时模式 现实中的网络情况错综复杂，远程服务器的状态也未必能保持百分百可用。为了保证良好的用户体验，需要对客户端的行为进行精细化的控制，比如：只等待 500ms，超过 500ms 仍然没有收到任何一个气象数据服务中心的响应，first 函数就返回失败。
在上面例子的基础上对 first 函数进行了调整：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 func first(servers ...*httptest.Server) (result, error) { c := make(chan result, len(servers)) queryFunc := func(server *httptest.Server) { url := server.URL resp, err := http.Get(url) if err != nil { log.Printf(&#34;http get error: %s\n&#34;, err) return } defer resp.Body.Close() body, _ := ioutil.ReadAll(resp.Body) c &lt;- result{ value: string(body), } } for _, serv := range servers { go queryFunc(serv) } select { case r := &lt;-c: return r, nil case &lt;-time.After(500 * time.Millisecond): // 主要就是增加了这里的一个定时器 return result{}, errors.New(&#34;timeout&#34;) } } 1 2 3 4 5 $ go run main.go 2022/09/18 22:58:13 open-weather-2 receive a http request 2022/09/18 22:58:13 open-weather-3 receive a http request 2022/09/18 22:58:13 open-weather-1 receive a http request 2022/09/18 22:58:14 invoke first error: timeout 示例3 取消模式 加上了超时模式的版本依然有一个明显的问题，即便 first 函数因超时而返回，三个已经创建的 goroutine 可能依然处在向气象数据中心请求或等待应答的状态，没有返回，也没有被回收，资源依然在占用，即使它们的存在已经没有任何意义。一种合理的思路是让这三个 goroutine 支持取消操作，可以使用 Go 的 context 包来实现取消模式。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 package main import ( &#34;context&#34; &#34;errors&#34; &#34;fmt&#34; &#34;io/ioutil&#34; &#34;log&#34; &#34;net/http&#34; &#34;net/http/httptest&#34; &#34;time&#34; ) type result struct { value string } func first(servers ...*httptest.Server) (result, error) { c := make(chan result) ctx, cancel := context.WithCancel(context.Background()) defer cancel() queryFunc := func(i int, server *httptest.Server) { url := server.URL req, err := http.NewRequest(&#34;GET&#34;, url, nil) // 不在使用http.Get，使用http.NewRequest可以创建一个带有context的req if err != nil { log.Printf(&#34;query goroutine-%d: http NewRequest error: %s\n&#34;, i, err) return } req = req.WithContext(ctx) log.Printf(&#34;query goroutine-%d: send request...\n&#34;, i) resp, err := http.DefaultClient.Do(req) if err != nil { log.Printf(&#34;query goroutine-%d: get return error: %s\n&#34;, i, err) return } log.Printf(&#34;query goroutine-%d: get response\n&#34;, i) defer resp.Body.Close() body, _ := ioutil.ReadAll(resp.Body) c &lt;- result{ value: string(body), } return } for i, serv := range servers { go queryFunc(i, serv) } select { case r := &lt;-c: // 如果取到了一个最先的数据，函数进行返回，在返回前触发了defer中的cancel()函数对其他的goroutine进行取消操作 return r, nil case &lt;-time.After(500 * time.Millisecond): return result{}, errors.New(&#34;timeout&#34;) } } func fakeWeatherServer(name string, interval int) *httptest.Server { return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { log.Printf(&#34;%s receive a http request\n&#34;, name) time.Sleep(time.Duration(interval) * time.Millisecond) w.Write([]byte(name + &#34;:ok&#34;)) })) } func main() { result, err := first(fakeWeatherServer(&#34;open-weather-1&#34;, 200), // 只有200的这个会被执行到 fakeWeatherServer(&#34;open-weather-2&#34;, 1000), fakeWeatherServer(&#34;open-weather-3&#34;, 600)) if err != nil { log.Println(&#34;invoke first error:&#34;, err) return } fmt.Println(result) time.Sleep(10 * time.Second) } 1 2 3 4 5 6 7 8 9 10 11 $ go run main.go 2022/09/18 23:47:35 query goroutine-1: send request... 2022/09/18 23:47:35 query goroutine-2: send request... 2022/09/18 23:47:35 query goroutine-0: send request... 2022/09/18 23:47:35 open-weather-2 receive a http request 2022/09/18 23:47:35 open-weather-3 receive a http request 2022/09/18 23:47:35 open-weather-1 receive a http request 2022/09/18 23:47:35 query goroutine-0: get response {open-weather-1:ok} 2022/09/18 23:47:35 query goroutine-1: get return error: Get &#34;http://127.0.0.1:64178&#34;: context canceled 2022/09/18 23:47:35 query goroutine-2: get return error: Get &#34;http://127.0.0.1:64179&#34;: context canceled ]]></content>
  </entry>
  
  <entry>
    <title>Go常见的并发模式 - 管道模式</title>
    <url>/post/2022/09/go-concurrency-pattern-3/</url>
    <categories><category>Go</category>
    </categories>
    <tags>
      <tag>Go</tag>
      <tag>并发</tag>
    </tags>
    <content type="html"><![CDATA[管道模式 在 Go 中管道模式被实现成了一条由 channel 连接的一条“数据流水线”。在该流水线中，每个数据处理环节都由一组功能相同的 goroutine 完成。在每个数据处理环节，goroutine 都要从数据输入 channel 获取前一个环节产生的数据，然后对这些数据进行处理，并将处理后的结果数据通过数据输出 channel 发往下一个环节。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 package main func newNumGenerator(start, count int) &lt;-chan int { c := make(chan int) go func() { for i := start; i &lt; start+count; i++ { c &lt;- i } close(c) }() return c } // 过滤掉奇数，保留偶数 func filterOdd(in int) (int, bool) { if in%2 != 0 { return 0, false } return in, true } // 求平方 func square(in int) (int, bool) { return in * in, true } func spawn(f func(int) (int, bool), in &lt;-chan int) &lt;-chan int { out := make(chan int) go func() { for v := range in { r, ok := f(v) if ok { out &lt;- r } } close(out) }() return out } func main() { in := newNumGenerator(1, 20) out := spawn(square, spawn(filterOdd, in)) // 可以把spawn(filterOdd, in)看成是一个in for v := range out { // 不关闭out通道，range会一直从out里读取数据，如果没有数据返回就读取为通道类型的零值 println(v) } } 1 2 3 4 5 6 7 8 9 10 11 $ go run main.go 4 16 36 64 100 144 196 256 324 400 管道模式具有良好的可扩展性，可以继续连接新的管道进行数据过滤和处理。
基于管道模式的另外两种扩展模式
扇出模式 fan-out 在某个处理环节，多个功能相同的 goroutine 从同一个 channel 读取数据并处理，直到该 channel 关闭。使用扇出模式可以在一组 goroutine 中均衡分配工作量，从而更均衡地利用 CPU。
扇入模式 fan-in 在某个处理环节，处理程序面对不止一个输入 channel。我们把所有输入 channel 的数据汇聚到一个统一的输入 channel，然后处理程序再从这个 channel 中读取数据并处理，直到该 channel 因所有输入 channel 关闭而关闭。
综合示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 package main import ( &#34;fmt&#34; &#34;sync&#34; &#34;time&#34; ) func newNumGenerator(start, count int) &lt;-chan int { c := make(chan int) go func() { for i := start; i &lt; start+count; i++ { c &lt;- i } close(c) }() return c } // 取偶数 func filterOdd(in int) (int, bool) { if in%2 != 0 { return 0, false } return in, true } // 求平方 func square(in int) (int, bool) { return in * in, true } func spawnGroup(name string, num int, f func(int) (int, bool), in &lt;-chan int) &lt;-chan int { groupOut := make(chan int) // Fan-out // // /-- out --\ // /	\ // in ---- --&gt; out ---- --&gt; outSlice // \	/ // \-- out --/ // var outSlice []chan int for i := 0; i &lt; num; i++ { out := make(chan int) go func(i int) { // 开启num个goroutine分别从in中接收数据 name := fmt.Sprintf(&#34;%s-%d:&#34;, name, i) fmt.Printf(&#34;%s begin to work...\n&#34;, name) for v := range in { r, ok := f(v) if ok { out &lt;- r } } close(out) fmt.Printf(&#34;%s work done\n&#34;, name) }(i) outSlice = append(outSlice, out) // 将多个out打包到一个slice中，提供给后续的Fan-in使用 } // Fan-in // // out --\ // \ // out ---- --&gt; groupOut // / // out --/ // go func() { var wg sync.WaitGroup for _, out := range outSlice { wg.Add(1) go func(out &lt;-chan int) { for v := range out { groupOut &lt;- v } wg.Done() }(out) } wg.Wait() close(groupOut) }() return groupOut } func main() { in := newNumGenerator(1, 20) out := spawnGroup(&#34;square&#34;, 2, square, spawnGroup(&#34;filterOdd&#34;, 3, filterOdd, in)) time.Sleep(3 * time.Second) for v := range out { fmt.Println(v) } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ❯ go run main.go square-0: begin to work... filterOdd-0: begin to work... filterOdd-1: begin to work... filterOdd-2: begin to work... square-1: begin to work... 4 36 16 100 196 144 64 256 324 400 ]]></content>
  </entry>
  
  <entry>
    <title>Go常见的并发模式 - 退出模式</title>
    <url>/post/2022/09/go-concurrency-pattern-2/</url>
    <categories><category>Go</category>
    </categories>
    <tags>
      <tag>Go</tag>
      <tag>并发</tag>
    </tags>
    <content type="html"><![CDATA[分离模式 分离模式是使用最为广泛的 goroutine 退出模式。对于分离的 goroutine，创建它的 goroutine 不需要关心它的退出，这类 goroutine 在启动后即与其创建者彻底分离，其生命周期与其执行者的主函数相关，函数返回即 goroutine 退出。这类 goroutine 有两个常见用途。
一次性任务 新创建的 goroutine 用来执行一个简单的任务，执行后即退出。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package main import ( &#34;time&#34; ) func stop(done chan struct{}) { go func() { timer := time.NewTimer(time.Second * 5) defer timer.Stop() select { case &lt;-timer.C: println(&#34;timeout!&#34;) case &lt;-done: println(&#34;done&#34;) } }() } func main() { done := make(chan struct{}) stop(done) time.Sleep(time.Second * 3) done &lt;- struct{}{} time.Sleep(time.Second * 7) } 1 2 3 4 5 6 $ go run main.go done 如果注释24 25行输出 $ go run main.go timeout! 常驻后台执行一些特定任务 如监视(motion)、观察(watch)等。其实现通常采用 for{&hellip;} 或 for{ select{&hellip;} } 代码段形式，并多以定时器（timer）或事件（event）驱动执行。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( &#34;fmt&#34; &#34;time&#34; ) func monitor() chan int { event := make(chan int) ticker := time.NewTicker(time.Second * 1) go func() { defer ticker.Stop() for { select { case e := &lt;-event: fmt.Println(&#34;Event at&#34;, e) case t := &lt;-ticker.C: fmt.Println(&#34;Tick at&#34;, t) } } }() return event } func main() { event := monitor() event &lt;- 1 time.Sleep(time.Second * 2) event &lt;- 2 time.Sleep(time.Second * 3) event &lt;- 3 time.Sleep(time.Second * 5) } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ go run main.go Event at 1 Tick at 2022-09-18 10:34:35.8135843 +0800 CST m=+1.013198701 Event at 2 Tick at 2022-09-18 10:34:36.8146391 +0800 CST m=+2.014253501 Tick at 2022-09-18 10:34:37.8163952 +0800 CST m=+3.016009601 Tick at 2022-09-18 10:34:38.8107951 +0800 CST m=+4.010409501 Tick at 2022-09-18 10:34:39.8063766 +0800 CST m=+5.005991001 Event at 3 Tick at 2022-09-18 10:34:40.8064387 +0800 CST m=+6.006053101 Tick at 2022-09-18 10:34:41.8058522 +0800 CST m=+7.005466601 Tick at 2022-09-18 10:34:42.8161325 +0800 CST m=+8.015746901 Tick at 2022-09-18 10:34:43.8137131 +0800 CST m=+9.013327501 Tick at 2022-09-18 10:34:44.814661 +0800 CST m=+10.014275401 join 模式 有时候 goroutine 的创建者需要等待新 goroutine 结束
等待一个 goroutine 退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import &#34;time&#34; func worker(args ...interface{}) { if len(args) == 0 { return } interval, ok := args[0].(int) // 获取第一个参数作为time.Duration的参数，由于是interface所以需要通过类型断言转换成int类型 if !ok { return } time.Sleep(time.Second * (time.Duration(interval))) } func spawn(f func(args ...interface{}), args ...interface{}) chan struct{} { c := make(chan struct{}) go func() { f(args...) c &lt;- struct{}{} }() return c } func main() { done := spawn(worker, 5) println(&#34;spawn a worker goroutine&#34;) &lt;-done // 直到收到信号前，会一直在这里阻塞住main goroutine println(&#34;worker done&#34;) } 1 2 3 $ go run main.go spawn a worker goroutine worker done spawn 函数使用典型的 goroutine 创建模式创建了一个 goroutine，main goroutine 作为创建者通过 spawn 函数返回的 channel 与新 goroutine 建立联系，这个 channel 的用途就是在两个 goroutine 之间建立退出事件的“信号”通信机制。main goroutine 在创建完新 goroutine 后便在该 channel 上阻塞等待，直到新 goroutine 退出前向该 channel 发送了一个信号，此时 main goroutine 中的 done channel 收到信号后解除了阻塞继续向下执行，直到 main goroutine 退出。
获取 goroutine 的退出状态 如果新 goroutine 的创建者不仅要等待 goroutine 的退出，还要精准获取其结束状态，同样可以通过自定义类型的 channel 来实现这一场景需求
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package main import ( &#34;errors&#34; &#34;fmt&#34; &#34;time&#34; ) var OK = errors.New(&#34;ok&#34;) func worker(args ...interface{}) error { if len(args) == 0 { return errors.New(&#34;invalid args&#34;) } interval, ok := args[0].(int) if !ok { return errors.New(&#34;invalid interval arg&#34;) } time.Sleep(time.Second * (time.Duration(interval))) return OK } func spawn(f func(args ...interface{}) error, args ...interface{}) chan error { c := make(chan error) // 承载的类型由struct{}改成了error，这样channel承载的信息就不只是一个信号了，还携带了有价值的信息：新goroutine的结束状态 go func() { c &lt;- f(args...) }() return c } func main() { done := spawn(worker, 5) println(&#34;spawn worker1&#34;) err := &lt;-done fmt.Println(&#34;worker1 done:&#34;, err) done = spawn(worker) println(&#34;spawn worker2&#34;) err = &lt;-done fmt.Println(&#34;worker2 done:&#34;, err) } 1 2 3 4 5 6 $ go run main.go spawn worker1 ok worker1 done: ok spawn worker2 worker2 done: invalid args 等待多个 goroutine 退出 在有些场景中，goroutine 的创建者可能会创建不止一个 goroutine，并且需要等待全部新 goroutine 退出，这时可以通过 Go 语言提供的 sync.WaitGroup 实现等待多个 goroutine 退出。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 package main import ( &#34;fmt&#34; &#34;sync&#34; &#34;time&#34; ) func worker(args ...interface{}) { if len(args) == 0 { return } interval, ok := args[0].(int) if !ok { return } time.Sleep(time.Second * (time.Duration(interval))) } func spawnGroup(n int, f func(args ...interface{}), args ...interface{}) chan struct{} { c := make(chan struct{}) var wg sync.WaitGroup for i := 0; i &lt; n; i++ { // spawnGroup创建了3个新的goroutine wg.Add(1) go func(i int) { name := fmt.Sprintf(&#34;worker-%d:&#34;, i) f(args...) println(name, &#34;done&#34;) wg.Done() // worker done! }(i) } go func() { wg.Wait() // 上面创建的3个goroutine执行结束后，wg.Wait()会停止阻塞，继续向下执行 c &lt;- struct{}{} // 向done channel发送结束信号 }() return c } func main() { done := spawnGroup(5, worker, 3) println(&#34;spawn a group of workers&#34;) &lt;-done // 收到信号后解除阻塞 println(&#34;group workers done&#34;) } 1 2 3 4 5 6 7 8 $ go run main.go spawn a group of workers worker-0: done worker-4: done worker-2: done worker-1: done worker-3: done group workers done 支持超时机制的等待 如果不想无限阻塞等待所有新创建 goroutine 的退出，可以仅等待一段合理的时间，如果在这段时间内 goroutine 没有退出（触发done），则创建者会继续向下执行或主动退出
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 省略部分代码...和上面例子中的相同... func main() { done := spawnGroup(5, worker, 30) println(&#34;spawn a group of workers&#34;) timer := time.NewTimer(time.Second * 5) defer timer.Stop() select { case &lt;-timer.C: // 5秒后这个channel会接收到一个通知，如果这之前done channel没有被触发，则主程序继续向下运行直到退出 println(&#34;wait group workers exit timeout!&#34;) case &lt;-done: println(&#34;group workers done&#34;) } } 1 2 3 $ go run main.go spawn a group of workers wait group workers exit timeout! notify-and-wait 模式 在前面的几个场景中，goroutine 的创建者都是在被动地等待着新 goroutine 的退出。但很多时候，goroutine 创建者需要主动通知那些新 goroutine 退出，尤其是当 main goroutine 作为创建者时。main goroutine 退出意味着 Go 程序终止，而粗暴地直接让 main goroutine 退出的方式可能会导致业务数据损坏、不完整或丢失。
可以通过 notify-and-wait（通知并等待）模式来满足这一场景的要求。虽然这一模式也不能完全避免损失，但是给了各个 goroutine 一个挽救数据的机会，从而尽可能减少损失。
通知并等待一个 goroutine 退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 package main import &#34;time&#34; func worker(j int) { time.Sleep(time.Second * (time.Duration(j))) } func spawn(f func(int)) chan string { quit := make(chan string) go func() { var job chan int // 模拟job channel for { select { case j := &lt;-job: // 这个例子中这里会一直阻塞住不会被执行到，只是一种模拟 f(j) case &lt;-quit: quit &lt;- &#34;ok&#34; // 承载新 goroutine 返回给创建者的退出状态 return } } }() return quit } func main() { quit := spawn(worker) println(&#34;spawn a worker goroutine&#34;) time.Sleep(5 * time.Second) // 通知子goroutine退出 println(&#34;notify the worker to exit...&#34;) quit &lt;- &#34;exit&#34; // 承载创建者发送给新 goroutine 的退出信号 timer := time.NewTimer(time.Second * 10) defer timer.Stop() select { case status := &lt;-quit: println(&#34;worker done:&#34;, status) case &lt;-timer.C: println(&#34;wait worker exit timeout&#34;) } } 1 2 3 4 $ go run main.go spawn a worker goroutine notify the worker to exit... worker done: ok 这里使用创建模式 goroutine 的 spawn 函数返回的 channel 的作用发生了变化，从原先的只是用于新 goroutine 发送退出信号给创建者，变成了一个双向的数据通道：既承载创建者发送给新 goroutine 的退出信号，也承载新 goroutine 返回给创建者的退出状态
通知并等待多个 goroutine 退出 Go 语言的 channel 有一个特性是，当使用 close 函数关闭 channel 时，所有阻塞到该 channel 上的 goroutine 都会得到通知。利用这一特性可以实现满足这一场景的模式。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 package main import ( &#34;fmt&#34; &#34;sync&#34; &#34;time&#34; ) func worker(j int) { time.Sleep(time.Second * (time.Duration(j))) } func spawnGroup(n int, f func(int)) chan struct{} { quit := make(chan struct{}) job := make(chan int) var wg sync.WaitGroup for i := 0; i &lt; n; i++ { wg.Add(1) go func(i int) { defer wg.Done() // 保证wg.Done在goroutine退出前被执行 name := fmt.Sprintf(&#34;worker-%d:&#34;, i) for { j, ok := &lt;-job // 通道被关闭后，ok会收到值false表示通道已经关闭了 if !ok { // 如果不用ok判断，依然可以从关闭的通道中收到通道类型的零值，所以这里用ok作为判断条件很重要 println(name, &#34;done&#34;) return } // do the job worker(j) } }(i) } go func() { &lt;-quit close(job) // 广播给所有新goroutine wg.Wait() quit &lt;- struct{}{} }() return quit } func main() { quit := spawnGroup(5, worker) println(&#34;spawn a group of workers&#34;) time.Sleep(5 * time.Second) // 通知 worker goroutine group 退出，接到通知后通过关闭job广播通知所有的子goroutine进行退出 println(&#34;notify the worker group to exit...&#34;) quit &lt;- struct{}{} timer := time.NewTimer(time.Second * 5) defer timer.Stop() select { case &lt;-timer.C: println(&#34;wait group workers exit timeout!&#34;) case &lt;-quit: println(&#34;group workers done&#34;) } } 1 2 3 4 5 6 7 8 9 ❯ go run main.go spawn a group of workers notify the worker group to exit... worker-2: done worker-3: done worker-0: done worker-1: done worker-4: done group workers done 退出模式的应用 很多时候，在程序中要启动多个 goroutine 协作完成应用的业务逻辑。但这些 goroutine 的运行形态很可能不同，有的扮演服务端，有的扮演客户端，等等，因此似乎很难用一种统一的框架全面管理它们的启动、运行和退出。但是可以尝试将问题范围缩小，聚焦在实现一个“超时等待退出”框架，以统一解决各种运行形态 goroutine 的优雅退出问题。
一组 goroutine 的退出总体上有两种情况。一种是并发退出，在这类退出方式下，各个 goroutine 的退出先后次序对数据处理无影响，因此各个 goroutine 可以并发执行退出逻辑；另一种则是串行退出，即各个 goroutine 之间的退出时按照一定次序这个执行的，次序若错了可能会导致程序的状态混乱和错误。
示例通用部分代码：
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 package main import ( &#34;errors&#34; &#34;fmt&#34; &#34;sync&#34; &#34;time&#34; ) type GracefullyShutdowner interface { Shutdown(waitTimeout time.Duration) error } type ShutdownerFunc func(time.Duration) error func (f ShutdownerFunc) Shutdown(waitTimeout time.Duration) error { return f(waitTimeout) // 这里f的实参是shutdownMaker } // 并发退出 func ConcurrentShutdown(waitTimeout time.Duration, shutdowners ...GracefullyShutdowner) error { c := make(chan struct{}) go func() { var wg sync.WaitGroup for _, g := range shutdowners { wg.Add(1) go func(shutdowner GracefullyShutdowner) { defer wg.Done() shutdowner.Shutdown(waitTimeout) }(g) } wg.Wait() c &lt;- struct{}{} }() timer := time.NewTimer(waitTimeout) defer timer.Stop() select { case &lt;-c: // 正常退出 return nil case &lt;-timer.C: // 超时退出 return errors.New(&#34;wait timeout&#34;) } } // 串行退出 func SequentialShutdown(waitTimeout time.Duration, shutdowners ...GracefullyShutdowner) error { start := time.Now() var left time.Duration timer := time.NewTimer(waitTimeout) for _, g := range shutdowners { elapsed := time.Since(start) left = waitTimeout - elapsed c := make(chan struct{}) go func(shutdowner GracefullyShutdowner) { shutdowner.Shutdown(left) c &lt;- struct{}{} }(g) timer.Reset(left) select { case &lt;-c: // 正常退出 //continue case &lt;-timer.C: // 超时退出 return errors.New(&#34;wait timeout&#34;) } } return nil } func shutdownMaker(processTm int) func(time.Duration) error { return func(time.Duration) error { time.Sleep(time.Second * time.Duration(processTm)) return nil } } 并发退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { // TestConcurrentShutdown f1 := shutdownMaker(2) f2 := shutdownMaker(6) err := ConcurrentShutdown(10*time.Second, ShutdownerFunc(f1), ShutdownerFunc(f2)) if err != nil { fmt.Printf(&#34;TestConcurrentShutdown want nil, actual: %s&#34;, err) } err = ConcurrentShutdown(4*time.Second, ShutdownerFunc(f1), ShutdownerFunc(f2)) if err == nil { fmt.Printf(&#34;TestConcurrentShutdown want timeout, actual nil&#34;) } println(&#34;OK&#34;) } 串行退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func main() { // TestSequentialShutdown f1 := shutdownMaker(2) f2 := shutdownMaker(6) err := SequentialShutdown(10*time.Second, ShutdownerFunc(f1), ShutdownerFunc(f2)) if err != nil { fmt.Printf(&#34;TestSequentialShutdown want nil, actual: %s&#34;, err) } err = SequentialShutdown(5*time.Second, ShutdownerFunc(f1), ShutdownerFunc(f2)) if err == nil { fmt.Printf(&#34;TestSequentialShutdown want timeout, actual nil&#34;) } println(&#34;OK&#34;) } 串行退出有个问题是 waitTimeout 值的确定，因为这个超时时间是所有 goroutine 的退出时间之和。上面示例将每次的 left（剩余时间）传入下一个要执行的 goroutine 的 Shutdown 方法中。select 同样使用这个 left 作为 timeout 的值（通过 timer.Reset 重新设置 timer 定时器周期）。
]]></content>
  </entry>
  
  <entry>
    <title>Go常见的并发模式 - 创建模式</title>
    <url>/post/2022/09/go-concurrency-pattern-1/</url>
    <categories><category>Go</category>
    </categories>
    <tags>
      <tag>Go</tag>
      <tag>并发</tag>
    </tags>
    <content type="html"><![CDATA[在内部创建一个 goroutine 并返回一个 channel 类型的变量的函数，是 Go 中最常见的 goroutine 创建模式。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import &#34;fmt&#34; func spawn(f func() int) chan int { c := make(chan int) go func() { c &lt;- f() }() return c } func main() { c := spawn(func() int { return 100 }) fmt.Println(&lt;-c) } 1 2 $ go run main.go 100 spawn 函数创建的新 goroutine 与调用 spawn 函数的 goroutine 之间通过一个 channel 建立起了联系：两个 goroutine 可以通过这个 channel 进行通信。
]]></content>
  </entry>
  
  <entry>
    <title>关于 Hugo NexT 组织</title>
    <url>/about.html</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[To be continued&hellip;
]]></content>
  </entry>
  
</search>